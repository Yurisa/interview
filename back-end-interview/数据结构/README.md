## 数据结构
### 各种结构
#### 线性结构
- 数组
- 栈
- 队列
- 链表
- 哈希表
...
#### 树结构
- 二叉树
- 二分搜索树
- AVL
- 红黑树
- Treap
- Splay
- 堆
- Trie
- 线段树
- K-D树
- 并查集
- 哈弗曼树
...
### 图结构
- 邻接矩阵
- 邻接表

### 数组
#### 数组基础
- 把数据排成一排进行存放
- 数组最大的优点：快速查询。scores[2]
- 数组最好应用于"索引有语意"的情况

- 但也并非所有语意的索引都适用于数组 例如：身份证号：11011122344442
- 数组也可以处理"索引没有语意"的情况

#### 使用泛型
- 不可以是基本数据类型，只能是类对象
  - boolean
  - byte
  - char
  - short
  - int
  - long
  - float
  - double
- 每个基本类型都有对应的包装类
  - Boolean
  - Byte
  - Char
  - Short
  - Integer
  - Long
  - Float
  - Double


  ### 栈
  - 栈也是一种线性结构
  - 相比数组, 栈对应的操作是数组的子集
  - 只能从一端添加元素, 也只能从一端取出元素
  - 这一端称为栈顶

  #### 栈Stack
  - 栈是一种后进先出的数据结构
  - Last In First Out(LIFO)
  - 在计算机的世界里, 栈有着不可思议的作用

#### 栈的应用
- undo操作 - 编辑器
- 系统调用栈 - 操作系统
- 括号匹配 - 编辑器

### 队列Queue
- 队列是一种先进先出的数据结构
- First In First Out(FIFO)

### 链表
- 数据存储在"节点"(Node)中
- 优点：真正的动态, 不需要处理固定容量的问题
- 缺点：丧失了随机访问的能力

#### 数组和链表的对比
- 数组最好用于有语意的情况。scores[2]
- 最大优点：支持快速查询

- 链表不适合用于索引有语意的情况
- 最大的优点：动态


#### 实现队列和栈
- 使用动态数组实现栈
  - 时间复杂度
    - 出栈O(1)
    - 入栈O(1)
- 使用动态数组实现队列
  - 时间复杂度
    - 出队O(n)
    - 入队O(1)
- 循环队列
  - 时间复杂度
    - 出队O(1)
    - 入队O(1)
  - 头尾指针循环
- 使用链表实现栈
  - 时间复杂度
    - 出栈O(1)
    - 入栈Q(1)
  - 对链表头部操作复杂度为O(1)
- 使用带尾指针的链表实现队列  
  - 时间复杂度
    - 出队O(1)
    - 入队Q(1)
  - 头部出队, 尾部入队

### 二分搜索树(Binary Search Tree)
- 二分搜索树是二叉树
- 二分搜索树的每个节点的值
  - 大于其左子树的所有节点的值
  - 小于其右子树的所有节点的值
- 每一棵子树也是一棵二分搜索树
- 存储的元素必须有可比较性

### 集合Set
#### 链表和二分搜索树实现Set的性能对比
- LinkedListSet
  - 增add O(n)
  - 查contains O(n)
  - 删remove O(n)
- BSTSet
  - 增add O(h)
  - 查contains O(h)
  - 删remove O(h)
  - 注意：h为BST的高度
  - 平均
    - 增add O(logn)
    - 查contains O(logn)
    - 删remove O(logn)
#### 有序集合和无序集合
- 有序集合的元素具有顺序性 <-----基于搜索树的实现
- 无序集合中的元素没有顺序性 <-----基于哈希表的实现

### 映射(字典)Map
- BSTMap
  - 增add O(h)
  - 查contains O(h)
  - 删remove O(h)
  - 注意：h为BST的高度
  - 平均
    - 增add O(logn)
    - 查contains O(logn)
    - 删remove O(logn)
#### 有序映射和无序映射
- 有序集合的元素具有顺序性 <-----基于搜索树的实现
- 无序集合中的元素没有顺序性 <-----基于哈希表的实现