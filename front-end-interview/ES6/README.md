## ES6
### ES6模块化如何使用,开发环境如何打包
    - 模块化的基本语法
    - 开发环境配置
    - 关于JS众多模块化的标准
      - 没有模块化
      - AMD成为标准，require.js(也有CMD)
      - 前端打包工具，使得nodejs模块化可以被使用
      - ES6出现，想统一所有模块化标准
      - nodejs积极支持，浏览器尚未统一
      - 你可以自造lib，但是不要自造标准
    ** 解答 **
     - 语法:import export(注意有无default)
     - 环境:babel编译ES6语法，模块化可用webpack和rollup
     - 扩展:说一下自己对模块化标准统一的期待
### Class和普通构造函数有何区别
    - JS构造函数
    - Class基本语法
    - 语法糖
    - 继承
### Promise的基本使用和原理
    - Callback Hell
    - Promise语法
### 总结一下ES6其他常用功能
    - let/const
    - 多行字符串/模板变量
    - 解构赋值
    - 块级作用域
    - 函数默认参数
    - 箭头函数

### ES6模块化
#### ES6在语言标准的层面上, 实现了模块功能, 而且实现得相当简单, 完全可以取代现有的CommonJS和AMD规范, 成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想, 是尽量的静态化, 使得编译时就能确定模块的依赖关系, 以及输入和输出的变量。CommonJS和AMD模块, 都只能在运行时确定这些东西。比如, CommonJS模块就是对象, 输入时必须查找对象属性。ES6模块不是对象, 不是对象, 而是通过export命令显示指定输出的代码, 再通过import命令输入。
```
<span style="font-size:18px;">// ES6模块  
import { stat, exists, readFile } from 'fs';</span>  
```
上面代码的实质是从fs模块加载3个方法, 其他方法不加载。这种加载称为"编译时加载"或者静态加载, 即ES6可以在编译时就完成模块加载, 效率要比CommonJS模块的加载方式高。当然, 这也导致了没法引用ES6模块本身, 因为它不是对象。由于ES6模块是编译时加载, 使得静态分析成为可能。有了它, 就能进一步拓宽JavaScript的语法, 比如引入宏(macro)和类型检查(type system)这些只能靠静态分析实现的功能。除了静态分析实现的功能。